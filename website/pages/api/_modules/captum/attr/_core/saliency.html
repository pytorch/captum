
<script type="text/javascript" id="documentation_options" data-url_root="./"
  src="/js/documentation_options.js"></script>
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/underscore.js"></script>
<script type="text/javascript" src="/js/doctools.js"></script>
<script type="text/javascript" src="/js/language_data.js"></script>
<script type="text/javascript" src="/js/searchtools.js"></script>
<div class="sphinx"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<h1>Source code for captum.attr._core.saliency</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">import</span> <span class="nn">torch</span>

<span class="kn">from</span> <span class="nn">.._utils.common</span> <span class="k">import</span> <span class="n">_format_attributions</span><span class="p">,</span> <span class="n">format_input</span>
<span class="kn">from</span> <span class="nn">.._utils.attribution</span> <span class="k">import</span> <span class="n">GradientAttribution</span>
<span class="kn">from</span> <span class="nn">.._utils.gradient</span> <span class="k">import</span> <span class="n">apply_gradient_requirements</span><span class="p">,</span> <span class="n">undo_gradient_requirements</span>


<div class="viewcode-block" id="Saliency"><a class="viewcode-back" href="../../../../saliency.html#captum.attr._core.saliency.Saliency">[docs]</a><span class="k">class</span> <span class="nc">Saliency</span><span class="p">(</span><span class="n">GradientAttribution</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_func</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">"""</span>
<span class="sd">        Args:</span>

<span class="sd">            forward_func (callable): The forward function of the model or</span>
<span class="sd">                        any modification of it</span>
<span class="sd">        """</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">forward_func</span><span class="p">)</span>

<div class="viewcode-block" id="Saliency.attribute"><a class="viewcode-back" href="../../../../saliency.html#captum.attr._core.saliency.Saliency.attribute">[docs]</a>    <span class="k">def</span> <span class="nf">attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">abs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">additional_forward_args</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">""""</span>
<span class="sd">        A baseline approach for computing input attribution. It returns</span>
<span class="sd">        the gradients with respect to inputs. If `abs` is set to True, which is</span>
<span class="sd">        the default, the absolute value of the gradients is returned.</span>

<span class="sd">        More details about the approach can be found in the following paper:</span>
<span class="sd">            https://arxiv.org/pdf/1312.6034.pdf</span>

<span class="sd">        Args:</span>

<span class="sd">                inputs (tensor or tuple of tensors):  Input for which integrated</span>
<span class="sd">                            gradients are computed. If forward_func takes a single</span>
<span class="sd">                            tensor as input, a single input tensor should be provided.</span>
<span class="sd">                            If forward_func takes multiple tensors as input, a tuple</span>
<span class="sd">                            of the input tensors should be provided. It is assumed</span>
<span class="sd">                            that for all given input tensors, dimension 0 corresponds</span>
<span class="sd">                            to the number of examples (aka batch size), and if</span>
<span class="sd">                            mutliple input tensors are provided, the examples must</span>
<span class="sd">                            be aligned appropriately.</span>
<span class="sd">                target (int, optional):  Output index for which gradient is computed</span>
<span class="sd">                            (for classification cases, this is the target class).</span>
<span class="sd">                            If the network returns a scalar value per example,</span>
<span class="sd">                            no target index is necessary. (Note: Tuples for multi</span>
<span class="sd">                            -dimensional output indices will be supported soon.)</span>
<span class="sd">                            Default: None</span>
<span class="sd">                abs (bool, optional): Returns absolute value of gradients if set</span>
<span class="sd">                            to True, otherwise returns the (signed) gradients if</span>
<span class="sd">                            False.</span>
<span class="sd">                            Defalut: True</span>
<span class="sd">                additional_forward_args (tuple, optional): If the forward function</span>
<span class="sd">                            requires additional arguments other than the inputs for</span>
<span class="sd">                            which attributions should not be computed, this argument</span>
<span class="sd">                            can be provided. It must be either a single additional</span>
<span class="sd">                            argument of a Tensor or arbitrary (non-tuple) type or a</span>
<span class="sd">                            tuple containing multiple additional arguments including</span>
<span class="sd">                            tensors or any arbitrary python types. These arguments</span>
<span class="sd">                            are provided to forward_func in order following the</span>
<span class="sd">                            arguments in inputs.</span>
<span class="sd">                            Note that attributions are not computed with respect</span>
<span class="sd">                            to these arguments.</span>
<span class="sd">                            Default: None</span>

<span class="sd">        Return:</span>

<span class="sd">                attributions (tensor or tuple of tensors): The gradients with</span>
<span class="sd">                            respect to each input feature. Attributions will always be</span>
<span class="sd">                            the same size as the provided inputs, with each value</span>
<span class="sd">                            providing the attribution of the corresponding input index.</span>
<span class="sd">                            If a single tensor is provided as inputs, a single tensor is</span>
<span class="sd">                            returned. If a tuple is provided for inputs, a tuple of</span>
<span class="sd">                            corresponding sized tensors is returned.</span>


<span class="sd">        Examples::</span>

<span class="sd">            &gt;&gt;&gt; # ImageClassifier takes a single input tensor of images Nx3x32x32,</span>
<span class="sd">            &gt;&gt;&gt; # and returns an Nx10 tensor of class probabilities.</span>
<span class="sd">            &gt;&gt;&gt; net = ImageClassifier()</span>
<span class="sd">            &gt;&gt;&gt; # Generating random input with size 2x3x3x32</span>
<span class="sd">            &gt;&gt;&gt; input = torch.randn(2, 3, 32, 32, requires_grad=True)</span>
<span class="sd">            &gt;&gt;&gt; # Defining Saliency interpreter</span>
<span class="sd">            &gt;&gt;&gt; saliency = Saliency(net)</span>
<span class="sd">            &gt;&gt;&gt; # Computes saliency maps for class 3.</span>
<span class="sd">            &gt;&gt;&gt; attribution = saliency.attribute(input, target=3)</span>
<span class="sd">        """</span>
        <span class="c1"># Keeps track whether original input is a tuple or not before</span>
        <span class="c1"># converting it into a tuple.</span>
        <span class="n">is_inputs_tuple</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>

        <span class="n">inputs</span> <span class="o">=</span> <span class="n">format_input</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>
        <span class="n">gradient_mask</span> <span class="o">=</span> <span class="n">apply_gradient_requirements</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span>

        <span class="c1"># No need to format additional_forward_args here.</span>
        <span class="c1"># They are being formated in the `_run_forward` function in `common.py`</span>
        <span class="n">gradients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gradient_func</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forward_func</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">additional_forward_args</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">:</span>
            <span class="n">attributions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">gradient</span><span class="p">)</span> <span class="k">for</span> <span class="n">gradient</span> <span class="ow">in</span> <span class="n">gradients</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attributions</span> <span class="o">=</span> <span class="n">gradients</span>
        <span class="n">undo_gradient_requirements</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">gradient_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_format_attributions</span><span class="p">(</span><span class="n">is_inputs_tuple</span><span class="p">,</span> <span class="n">attributions</span><span class="p">)</span></div></div>
</pre></div>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">Captum</a></h1>
<h3>Navigation</h3>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../saliency.html">Saliency</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../deep_lift.html">DeepLift</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../deep_lift_shap.html">DeepLiftShap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../gradient_shap.html">GradientShap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../input_x_gradient.html">InputXGradient</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../integrated_gradients.html">IntegratedGradients</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../noise_tunnel.html">NoiseTunnel</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../base.html">base</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../neuron.html">neuron</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../layer.html">layer</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="../../../../index.html">Documentation overview</a><ul>
<li><a href="../../../index.html">Module code</a><ul>
</ul></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="../../../../search.html" class="search" method="get">
<input aria-labelledby="searchlabel" name="q" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div></div>