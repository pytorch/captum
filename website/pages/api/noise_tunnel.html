
<script type="text/javascript" id="documentation_options" data-url_root="./"
  src="/js/documentation_options.js"></script>
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/underscore.js"></script>
<script type="text/javascript" src="/js/doctools.js"></script>
<script type="text/javascript" src="/js/language_data.js"></script>
<script type="text/javascript" src="/js/searchtools.js"></script>
<div class="sphinx"><div class="document">
<div class="documentwrapper">
<div class="bodywrapper">
<div class="body" role="main">
<div class="section" id="module-captum.attr._core.noise_tunnel">
<span id="noisetunnel"></span><h1>NoiseTunnel<a class="headerlink" href="#module-captum.attr._core.noise_tunnel" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="captum.attr._core.noise_tunnel.NoiseTunnel">
<em class="property">class </em><code class="sig-prename descclassname">captum.attr._core.noise_tunnel.</code><code class="sig-name descname">NoiseTunnel</code><span class="sig-paren">(</span><em class="sig-param">attribution_method</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/attr/_core/noise_tunnel.html#NoiseTunnel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#captum.attr._core.noise_tunnel.NoiseTunnel" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>attribution_method (Attribution): An instance of any attribution algorithm</dt><dd><p>of type <cite>Attribution</cite>. E.g. Integrated Gradients, Conductance or
Saliency.</p>
</dd>
</dl>
<dl class="method">
<dt id="captum.attr._core.noise_tunnel.NoiseTunnel.attribute">
<code class="sig-name descname">attribute</code><span class="sig-paren">(</span><em class="sig-param">inputs</em>, <em class="sig-param">nt_type='smoothgrad'</em>, <em class="sig-param">n_samples=5</em>, <em class="sig-param">stdevs=1.0</em>, <em class="sig-param">draw_baseline_from_distrib=False</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/captum/attr/_core/noise_tunnel.html#NoiseTunnel.attribute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#captum.attr._core.noise_tunnel.NoiseTunnel.attribute" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds gaussian noise to each input in the batch <cite>n_samples</cite> times
and applies the given attribution algorithm to each of the samples.
The attributions of the samples are combined based on the given noise
tunnel type (nt_type):
If nt_type is <cite>smoothgrad</cite>, the mean of the sampled attributions is
returned. This approximates smoothing the given attribution method
with a Gaussian Kernel.
If nt_type is <cite>smoothgrad_sq</cite>, the mean of the squared sample attributions
is returned.
If nt_type is <cite>vargrad</cite>, the variance of the sample attributions is
returned.</p>
<dl class="simple">
<dt>More details about adding noise can be found in the following papers:</dt><dd><p><a class="reference external" href="https://arxiv.org/abs/1810.03292">https://arxiv.org/abs/1810.03292</a>
<a class="reference external" href="https://arxiv.org/abs/1810.03307">https://arxiv.org/abs/1810.03307</a>
<a class="reference external" href="https://arxiv.org/abs/1706.03825">https://arxiv.org/abs/1706.03825</a>
<a class="reference external" href="https://arxiv.org/pdf/1806.10758">https://arxiv.org/pdf/1806.10758</a></p>
</dd>
</dl>
<p>This method currently also supports batches of multiple examples input,
however it can be computationally expensive depending on the model,
the dimensionality of the data and execution environment.
It is assumed that the batch size is the first dimension of input tensors.</p>
<blockquote>
<div><p>Args:</p>
<blockquote>
<div><dl class="simple">
<dt>inputs (tensor or tuple of tensors):  Input for which integrated</dt><dd><p>gradients are computed. If forward_func takes a single
tensor as input, a single input tensor should be provided.
If forward_func takes multiple tensors as input, a tuple
of the input tensors should be provided. It is assumed
that for all given input tensors, dimension 0 corresponds
to the number of examples, and if mutliple input tensors
are provided, the examples must be aligned appropriately.</p>
</dd>
<dt>nt_type (string, optional): Smoothing type of the attributions.</dt><dd><p><cite>smoothgrad</cite>, <cite>smoothgrad_sq</cite> or <cite>vargrad</cite>
Default: <cite>smoothgrad</cite> if <cite>type</cite> is not provided.</p>
</dd>
<dt>n_samples (int, optional):  The number of randomly generated examples</dt><dd><p>per sample in the input batch. Random examples are
generated by adding gaussian random noise to each sample.
Default: <cite>5</cite> if <cite>n_samples</cite> is not provided.</p>
</dd>
<dt>stdevs    (float, or a tuple of floats optional): The standard deviation</dt><dd><p>of gaussian noise with zero mean that is added to each
input in the batch. If <cite>stdevs</cite> is a single float value
then that same value is used for all inputs. If it is
a tuple, then it must have the same length as the inputs
tuple. In this case, each stdev value in the stdevs tuple
corresponds to the input with the same index in the inputs
tuple.
Default: <cite>1.0</cite> if <cite>stdevs</cite> is not provided.</p>
</dd>
<dt>draw_baseline_from_distrib (bool, optional): Indicates whether to</dt><dd><p>randomly draw baseline samples from the <cite>baselines</cite>
distribution provided as an input tensor.
Default: False</p>
</dd>
<dt><a href="#id1"><span class="problematic" id="id2">**</span></a>kwargs (Any, optional): Contains a list of arguments that are passed</dt><dd><p>to <cite>attribution_method</cite> attribution algorithm.
Any additional arguments that should be used for the
chosen attribution method should be included here.
For instance, such arguments include
<cite>additional_forward_args</cite> and <cite>baselines</cite>.</p>
</dd>
</dl>
</div></blockquote>
<p>Return:</p>
<blockquote>
<div><dl class="simple">
<dt>attributions (tensor or tuple of tensors): Attribution with</dt><dd><p>respect to each input feature. attributions will always be
the same size as the provided inputs, with each value
providing the attribution of the corresponding input index.
If a single tensor is provided as inputs, a single tensor is
returned. If a tuple is provided for inputs, a tuple of
corresponding sized tensors is returned.</p>
</dd>
<dt>delta (float, optional): Approximation error computed by the</dt><dd><p>attribution algorithm. Not all attribution algorithms
return delta value. It is computed only for some
algorithms, e.g. integrated gradients.
Delta is computed for each input in the batch
and represents the arithmetic mean
across all <cite>n_sample</cite> pertubed tensors for that input.</p>
</dd>
</dl>
</div></blockquote>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># ImageClassifier takes a single input tensor of images Nx3x32x32,</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># and returns an Nx10 tensor of class probabilities.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">net</span> <span class="o">=</span> <span class="n">ImageClassifier</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ig</span> <span class="o">=</span> <span class="n">IntegratedGradients</span><span class="p">(</span><span class="n">net</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">requires_grad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Creates noise tunnel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nt</span> <span class="o">=</span> <span class="n">NoiseTunnel</span><span class="p">(</span><span class="n">ig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generates 10 perturbed input tensors per image.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Computes integrated gradients for class 3 for each generated</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># input and averages attributions accros all 10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># perturbed inputs per image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">attribution</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">attribute</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">nt_type</span><span class="o">=</span><span class="s1">'smoothgrad'</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                                  <span class="n">n_samples</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
</dd></dl>
</dd></dl>
</div>
</div>
</div>
</div>
<div aria-label="main navigation" class="sphinxsidebar" role="navigation">
<div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Captum</a></h1>
<h3>Navigation</h3>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="saliency.html">Saliency</a></li>
<li class="toctree-l1"><a class="reference internal" href="deep_lift.html">DeepLift</a></li>
<li class="toctree-l1"><a class="reference internal" href="deep_lift_shap.html">DeepLiftShap</a></li>
<li class="toctree-l1"><a class="reference internal" href="gradient_shap.html">GradientShap</a></li>
<li class="toctree-l1"><a class="reference internal" href="input_x_gradient.html">InputXGradient</a></li>
<li class="toctree-l1"><a class="reference internal" href="integrated_gradients.html">IntegratedGradients</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">NoiseTunnel</a></li>
<li class="toctree-l1"><a class="reference internal" href="base.html">base</a></li>
<li class="toctree-l1"><a class="reference internal" href="neuron.html">neuron</a></li>
<li class="toctree-l1"><a class="reference internal" href="layer.html">layer</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
<li><a href="index.html">Documentation overview</a><ul>
<li>Previous: <a href="integrated_gradients.html" title="previous chapter">IntegratedGradients</a></li>
<li>Next: <a href="base.html" title="next chapter">base</a></li>
</ul></li>
</ul>
</div>
<div id="searchbox" role="search" style="display: none">
<h3 id="searchlabel">Quick search</h3>
<div class="searchformwrapper">
<form action="search.html" class="search" method="get">
<input aria-labelledby="searchlabel" name="q" type="text"/>
<input type="submit" value="Go"/>
</form>
</div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
</div>
</div>
<div class="clearer"></div>
</div></div>